[toc]

# [섹션3] 영속성 관리 - 내부 동작 방식

### 1. 영속성 컨택스트 1

- JPA에서 가장 중요한 2가지

  - 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping) 
  - 영속성 컨텍스트

- 엔티티 매니저 팩토리와 엔티티 매니저

- 영속성 컨텍스트는 뭘까?

  - **JPA를 이해하는데 가장 중요한 용어** 
  - **엔티티를 영구 저장하는 환경**이라는 뜻
  - EntityManager.persist(entity) : 실제로는 더 깊은 내용이 있음.
    - 영속성 컨택스트를 통해 영속화 한다는 것.
    - 영속성 컨택스트라는 공간에 저장한다???

- 엔티티 매니저? 영속성 컨텍스트?

  - 하지만 영속성 컨텍스트는 논리적인 개념이며 눈에 보이지 않는다. 
  - 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

- 엔티티의 생명주기

  - 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 

    ```java
    // 객체를 생성만한 상태, JPA 와 전혀 관계가 없는 상태
    Member member = new Member();
    member.setId(1L);
    member.setName("유동관");
    ```

  - 영속 (managed) : 영속성 컨텍스트에 **관리**되는 상태 

    ```java
    entityManager.persist(member);	// entityManager에서 관리시작하는 상태
    ```

  - 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 --- detach

  - 삭제 (removed) : 삭제된 상태 --- remove

### 2. 영속성 컨택스트 2

- 영속성 컨텍스트의 이점

  - 내부에 1차 캐시를 가지고 있다.

    - 조회할 때 1차적으로 캐시에서 조회하므로 속도가 빠르다.

      ![image-20200319134831391](C:\Users\KTNET\AppData\Roaming\Typora\typora-user-images\image-20200319134831391.png)

  - 영속 엔티티의 동일성(identity) 보장 

    - 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 **애플리케이션 차원에서 제공**

  - 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)

    - tx.commit() 전까지 쿼리를 **쓰기지연 SQL 저장소에** 다 쌓아놓고 있는다.

      ![image](https://user-images.githubusercontent.com/26649731/77033321-38893000-69ea-11ea-819c-230376d79557.png)

    - 커밋을 때리는 순간(플러시) 가 되면서 날라간다.

    - 왜쓰지?

      - 버퍼링 기능. 최적화 용이

  - **변경 감지(Dirty Checking) : 업데이트 시**

    - 신기한놈이다.. setName 하면 지가 알아서 update 쿼리를 날려준다. 따로 update 메서드를 쓰지 않아도 된다.
    - 왜그러냐면 1차 캐시에서 스냅샷도 저장해 놓기 때문이다. 커밋하는 순간 스냅샷을 비교해서 바뀐게 존재한다? 그럼 Update 쿼리를 쓰기지연 SQL 저장소에 반영한다.
    - 그러니까 **따로 업데이트구문을 생각 안해줘도 된다는 것에 주의하자**

  - 지연로딩 : 나중에 할꺼임.

### 3. 플러시

- 플러시란?
  - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것을 말한다.
- 플러시 발생
  - 변경 감지 
  - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 
  - 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)
- 영속성 컨텍스트를 플러시하는 방법
  - em.flush() - 직접 호출
    - 강제로 먼저 호출해서 반영해보고자 할 때. 테스트해보고자 할 때.
  - **트랜잭션 커밋 - 플러시 자동 호출**
  - JPQL 쿼리 실행 - 플러시 자동 호출
- 플러시 모드 옵션
  - FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (기본값) 
  - ~~FlushModeType.COMMIT : 커밋할 때만 플러시~~
- 플러시 정리
  - 영속성 컨텍스트를 비우지 않음 
  - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 
  - **트랜잭션이라는 작업 단위가 중요 ---> 커밋 직전에만 동기화 하면 됨**

### 4. 준영속 상태

- 준영속 상태란?
  - 영속 -> 준영속 
  - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 
  - 영속성 컨텍스트가 제공하는 기능을 사용 못함
- 준영속 상태로 만드는 법
  - em.detach(entity) : 특정 엔티티만 준영속 상태로 전환 
  - em.clear() : 영속성 컨텍스트를 완전히 초기화 - 1차 캐시를 지워버림.
  - em.close() : 영속성 컨텍스트를 종료 - 영속성 컨택스트를 아예 끝내버림.

### 5. 정리

- JPA 가장 중요한 2가지
  - 정적 매핑
  - 실제 돌아가는 매커니즘 공부
- 영속성 컨택스트
  - 비영속, 영속, 준영속, 삭제