# 프로그래머스

[TOC]



## Level1

### 1. 소수의 합

- [에라토스테네스의 체](https://marobiana.tistory.com/91)를 공부해야 한다

- 알고 있다고 생각했는데 막상 구현해보면 모르는 알고리즘이니 잘 파악해두자
  1. 배열을 2부터 N까지 숫자를 차례대로 채운다.

  2. 2차원 배열을 이용하여 2부터 시작해서 배수를 다 0으로 만든다.

     ```c++
     for(int j=i*2;j<=N;j+=i)
     ```

  3. 체에 걸러진 것 제외 나머지 숫자들을 벡터에 담아 처리한다.

```c++
#include <vector>
#include <iostream>

using namespace std;

long long solution(int N) {
	long long answer = 0;
    // N으로 하면 9일때 8 인덱스까지 생기니까 하나 더 더해줘야 한다.
	vector<int> arr(N+1);
	for (int i = 2; i <= N; i++) {
		arr[i] = i;
	}
	for (int i = 2; i <= N; i++) {
		if (arr[i] == 0)continue;
        //i=2에서부터 시작하기 때문에 2 곱한것부터 시작해도 됀다.
		for (int j = i*2; j <= N; j += i) {
			arr[j] = 0;
		}
	}
	for (int i = 2; i <= N; i++) {
		if (arr[i] != 0) {
			answer += arr[i];
		}
	}

	return answer;
}
int main() {

	cout<<solution(7);

	return 0;
}
```

### 2. 완주하지 못한 선수

- map 에 대해 할 수 있었다.

```c++
#include <string>
#include <vector>
#include<iostream>
#include<map>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
	string answer = "";
	map<string, int> arr;
	for (auto elem : completion) {
        // 못찾았다면
		if (arr.find(elem) == arr.end()) {
			arr.insert({ elem,1 });
		}
		else {
			arr[elem]++;
		}
	}
	for (auto elem : participant) {
        // 해쉬에서 못찾았다면
		if (arr.find(elem) == arr.end()) {
			answer += elem;
			break;
		}
		else {
			arr[elem]--;
            // 0까지도 상관 없다. 하지만 음수가 되면 안된다.
			if (arr[elem] < 0) {
				answer += elem;
				break;
			}
		}
	}

	return answer;
}
```



## level2

### 1. 탑

- 왼쪽으로 레이져를 쏴서 걸리는거 넣어주면 된다.
- 이중 포문을 이용하여 간단하게 풀이하였음

```c++
#include <string>
#include <vector>
#include<iostream>
using namespace std;

vector<int> solution(vector<int> heights) {
	vector<int> answer;
	for (int i = 0; i < heights.size(); i++) {
		bool check = false;
		for (int j = i; j >= 0; j--) {
			if (heights[i] < heights[j]) {
				answer.push_back(j+1);
				check = true;
				break;
			}
		}
		if(!check)
			answer.push_back(0);
	}

	return answer;
}

int main() {

	vector<int> arr = { 3,9,9,3,5,7,2 };
	vector<int> answ = solution(arr);
	for (int i = 0; i < answ.size(); i++) {
		cout << answ[i] << " ";
	}
	return 0;
}
```

### 2. 스킬트리

- 뒤에 있는 단어가 먼저 나오면 안된다.

```c++
#include <string>
#include <vector>
#include<iostream>
using namespace std;

int solution(string skill, vector<string> skill_trees) {
	int answer = 0;
	/* 
	1. skill의 요소가 skill_trees에서 요소 몇번째 있는지 확인한다.
	2. 그 요소가 순서가 어긋나면 안된다.
	*/
	for (string s : skill_trees) {
		int a = 0;	// 요소가 위치해야만 하는 인덱스.
		bool c = true;
		for (int i = 0; i < s.size(); i++) {
			int idx = skill.find(s[i]);	// 이게 핵심..
			if (idx == -1)continue;
			if (a == idx) {	// 스킬트리 기초부터 찍었는가?
				a++;
			}
			else {
				c = false;
				break;
			}
		}
		if (c) {
			answer++;
		}
	}
	return answer;
}

int main() {
	string skill = "cbd";
	vector<string> arr = { "bacde","cbadf","aecb","bda" };

	int answ = solution(skill, arr);
	cout << answ << endl;
	return 0;
}
```

